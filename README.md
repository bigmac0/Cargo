# Cargo - A Ridesharing Algorithms Library

Dynamic ridesharing is a type of vehicle routing problem (VRP) closely related
to the variants known as PDPTW (or VRPPDTW) and DARP (dial-a-ride).

The problem for folks studying ridesharing algorithms is that these algorithms
are hard to implement. Something as simple as a nearest neighbor strategy takes
much time to develop because there is a lot of scaffolding that needs to be
built, e.g. a graph class for representing the road network, a generator to
broadcast customer requests, a mechanism to track the state of the moving
vehicles, etc.

A library of abstractions would make it easier to develop these algorithms and
hence to study them. The goal of the Cargo library is to provide these
abstractions. Because ridesharing in the real world is an online problem, Cargo
is targeted at online algorithms. The main features of Cargo are:
- a Simulator that broadcasts customer requests and arriving vehicles in real
  time.
- a generic Solution class. The aim of a Solution is to intercept broadcasted
  requests and vehicles and perform ridesharing assignments. The class is
flexible enough to support many ridesharing algorithms.  But the flexibility
comes at the sacrifice of usefulness; hence the onus is on the user to
implement any custom classes required by a Solution, e.g. a custom data
structure for storing vehicle schedules.
- a Controller. The Controller administers the shared requests queue between
  the Simulator and a Solution. Requests broadcasted by the Simulator are
pushed into the queue by the Controller; then, Solutions grab from this queue
when they want to make matchings. Similarly, vehicles broadcasted by the
Simulator notify the Controller to notify a Solution.
- a Logger. The Logger collects statistics generated by the Controller and
  writes them to disk for offline analysis.

### Simulator

The purposes of the simulator are to
- broadcast requests and vehicles in real time, and
- simulate the ground-truth movement of the vehicles.

The Simulator uses an in-memory sqlite3 database to record the ground-truth
state.  The database is created per problem instance, and is destroyed when the
simulation ends. It is never saved to disk. Only the Simulator has write-access
to the database.

### Solution

todo

### Logger

todo

### Similar projects

- [Open-VRP](https://github.com/mck-/Open-VRP)
- [jsprit](https://github.com/graphhopper/jsprit)
- [VRPH](https://projects.coin-or.org/VRPH)

## Prerequisites

Users should have pthreads. The simulator's Run() loop blocks an
entire thread. The recommended usage is to execute the loop on a separate
thread, and execute a Solution on the main thread.

Users must have the [METIS graph partitioning
library](http://glaros.dtc.umn.edu/gkhome/metis/metis/overview) installed.
Cargo provides a gtree (Zhong et al 2015)  spatial index for computing shortest
paths, and METIS is required to build this dependency.

Cargo also uses [sqlite3](https://sqlite.org/index.html) for managing
simulation state. Access is through
[sqlite_modern_cpp](https://github.com/SqliteModernCpp/sqlite_modern_cpp).
This wrapper can insert vectors easily into the db by converting them into blob
data. In Cargo, the base Schedule and Route data types are represented as
vectors. Schedules are vectors of stop IDs, and Routes are vectors of node IDs.

Schema for the ground-truth simulation state tables:
```
____________________─┐
| VEHICLES         | │
-------------------- ┘
| id (int)         | │
| load (int)       |
| nnd (double)     | // next-node distance
| early (int)      | // in sim time units
| late (int)       | // in sim time units
| origin (int)     |
| dest (int)       |
| route_trav (blob)| // traveled route, vector<int>
| route_rem (blob) | // remaining route, vector<int>
| sched (blob)     | // vector<int> of stop IDs ------------------
--------------------                                             |
                                                                 |
____________________                                             |
| STOPS            |                                             |
--------------------                                             |
| id (int)         | <--------------------------------------------
| trip_id (int)    | // corresponds to the cust/veh
| node_id (int)    |
| type (int)       | // 1=cust-origin;2=cust-dest;3=veh-origin;4=veh-dest
| visit_time (int) | // defaults to early if type=1,3; late if type=2,4
--------------------
```

## Usage

Build the library using `make`. The library will be placed into `lib/libcargo.a`
after building. Then, in your own project, include the header to access the
libcargo API. The `include/` folder should be placed somewhere your compiler
can access.
```cpp
// myproj.cpp
#include "libcargo.h"
int main() {
    cargo::opts::Options myOpts;
    myOpts.RoadNetworkPath = "...";
    ... // set options

    cargo::Simulator mySim;
    mySim.SetOptions(myOpts);
    mySim.Initialize();

    mySim.Run(); // this should be on a separate thread
}
```

To compile, link the library (and don't forget to link METIS).
`g++ myproj.cpp -L/path/to/cargo -lcargo -L/path/to/metis -lmetis`

## To do (check means passed tests):

- [x] Distance functions (Euclidean and Haversine)
- [x] Message class provides four levels of colored terminal output
- [ ] Semantic types match the ridesharing problem's vocabulary and entities
- [ ] Simulator tracks the state of the simulation at every time step
- [ ] Simulator broadcasts new vehicle and customer arrivals to matching algs
- [ ] Implement some matching algs
- [ ] Logging class logs statistics to disk

Help wanted! Please feel free to throw pull requests at me.
