#!/usr/bin/env python3
""" Authors:
Juntao Hu <hujuntao@buaa.edu.cn>
James J. Pan <jamesjpan@outlook.com>
"""
import argparse
import math
import networkx as nx
import random
import sys

""" Parses trips out of a raw trip file
Expects the format, sorted by trip start time (column 3):
    tax_id yyy/m/dd hh:mm:ss o_lng o_lat yyyy/m/dd hh:mm:ss d_lng d_lat
"""
def rspgen_real(args):
    node = {}
    graph = nx.Graph()
    with open(args["rnet_file"]) as f_rnet:
        for line in f_rnet:
            col = line.strip().split(' ')
            o = int(col[1])
            d = int(col[2])
            lon1 = float(col[3])
            lat1 = float(col[4])
            lon2 = float(col[5])
            lat2 = float(col[6])
            node[o] = (lon1, lat1)
            node[d] = (lon2, lat2)
            graph.add_node(o)
            graph.add_node(d)
            graph.add_edge(o, d, weight=haversine(lon1, lat1, lon2, lat2))
    print('total nodes:', graph.number_of_nodes())
    print('total edges:', graph.number_of_edges())

    f_out = open(args["out"], 'w')
    f_out.write(args["out"]+'\n')
    rnet_name = args["rnet_file"].split('/').pop().split('.rnet')[0]
    f_out.write(rnet_name+'\n')
    f_out.write('VEHICLES '+args["num_vehicles"]+'\n')
    f_out.write('CUSTOMERS '+args["num_customers"]+'\n')
    f_out.write('\n')
    f_out.write('ID\tORIGIN\tDEST\tQ\tEARLY\tLATE\n')
    trip = []
    i = 1
    m = int(args["num_vehicles"])
    n = int(args["num_customers"])
    with open(args["trips_file"]) as f_trips:
        sthr = int(args["start_hour"])
        for line in f_trips:
            col = line.strip().split(' ')
            tm = col[2].split(':')
            hr = int(tm[0])
            mn = int(tm[1])
            sc = int(tm[2])
            base = sthr*3600 # seconds
            if hr >= sthr:
                tmstmp = hr*3600+mn*60+sc
                diff = tmstmp - base
                o_lon = float(col[3])
                o_lat = float(col[4])
                d_lon = float(col[7])
                d_lat = float(col[8])
                near_o = nearest_node(o_lon, o_lat, int(args["tolerance"]), node)
                near_d = nearest_node(d_lon, d_lat, int(args["tolerance"]), node)
                if near_o != -1 and near_d != -1:
                    trip_time = sp_time(near_o, near_d, args["speed"], graph)
                    trip_late = trip_time + diff + random.randint(0, int(args["delay"]*600))
                    cap = 1;
                    if i <= m: # is a vehicle
                        if i < m*.1:
                            cap = 7
                        elif i < m*.6:
                            cap = 3
                        elif i < m*.8:
                            cap = 2
                        f_out.write('\t'.join([str(i), str(near_o), str(near_d), str(-cap),
                            str(diff), str(trip_late)+'\n']))
                    else:
                        f_out.write('\t'.join([str(i), str(near_o), str(near_d), str(1),
                            str(diff), str(trip_late)+'\n']))
                    sys.stdout.write('{}\{}\r'.format(i,(m+n)))
                    sys.stdout.flush()
                    i+=1
                    if i > m+n:
                        break
    f_out.close()


def haversine(lon1, lat1, lon2, lat2):
    radius = 6371000  # meters
    dlat = math.radians(lat2-lat1)
    dlon = math.radians(lon2-lon1)
    a = math.sin(dlat / 2) * math.sin(dlat / 2) + math.cos(math.radians(lat1)) * \
        math.cos(math.radians(lat2)) * \
        math.sin(dlon / 2) * math.sin(dlon / 2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return radius * c


def nearest_node(lon, lat, tol, node_dict):
    d_min = float("inf")
    near_node = -1
    for node_id in node_dict:
        d = haversine(node_dict[node_id][0], node_dict[node_id][1], lon, lat)
        if d < d_min and d <= tol:
            d_min = d
            near_node = node_id
    return near_node


def sp_time(o, d, speed, graph):
    d = nx.shortest_path_length(graph, source=o, target=d, weight='weight')
    return round(d/speed)


def get_parser():
    p = argparse.ArgumentParser(description="Generate RSP R instances")
    p.add_argument("rnet_file")
    p.add_argument("trips_file")
    p.add_argument("num_customers")
    p.add_argument("num_vehicles")
    p.add_argument("start_hour", choices=['0','1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23'])
    p.add_argument("-s", "--speed", metavar="SPEED", type=int, help="vehicle speed (default: 10 m/s)", default=10)
    p.add_argument("-d", "--delay", metavar="DELAY", type=int, help="max vehicle delay (default: 10 min)", default=10)
    p.add_argument("-t", "--tolerance", metavar="TOL", type=int, help="max tolerance for map-matching (default: 100 meters)", default=100)
    p.add_argument("-o", "--out", metavar="OUTPUT", help="output dest (default: a.instance)", default="a")
    return p;


if __name__ == "__main__":
    rspgen_real(vars(get_parser().parse_args()))
