#!/usr/bin/env python3
""" Authors:
Juntao Hu <hujuntao@buaa.edu.cn>
James J. Pan <jamesjpan@outlook.com>
"""
from collections import defaultdict, namedtuple
import networkx as nx
import random
import math
import argparse
import sys

Node = namedtuple('Node', ['id', 'lon', 'lat'])

class TripGenerator:
    min_lon = 1000
    min_lat = 1000
    max_lon = 0
    max_lat = 0

    nodes = dict()
    grid_index = defaultdict(lambda: list(), dict())
    graph = nx.Graph()

    def __init__(self, grid_size, rnet_file):
        self.grid_size = grid_size
        self.rnet = rnet_file
        road = open(rnet_file, 'r')

        while True:
            line = road.readline()
            if line:
                line = line.split(' ')
                o = int(line[1])
                d = int(line[2])
                o_lon = float(line[3])
                o_lat = float(line[4])
                d_lon = float(line[5])
                d_lat = float(line[6])
                self.nodes[o] = Node(o, o_lon, o_lat)
                self.nodes[d] = Node(d, d_lon, d_lat)
                self.set_min_max(self.nodes[o])
                self.set_min_max(self.nodes[d])
                self.graph.add_node(o)
                self.graph.add_node(d)
                self.graph.add_edge(o, d, weight=self.haversine(
                    self.nodes[o], self.nodes[d]))
            else:
                break

        road.close()
        print(self.min_lon, self.max_lon, self.min_lat, self.max_lat)
        self.grid_lon = (self.max_lon - self.min_lon) / grid_size
        self.grid_lat = (self.max_lat - self.min_lat) / grid_size

        for idx in self.nodes:
            node = self.nodes[idx]
            self.grid_index[self.get_index(node)].append(node.id)

        print('total nodes:', self.graph.number_of_nodes())
        print('total edges:', self.graph.number_of_edges())

    def generate(self, prefix, num, vehs, custs, speed, freq, delay, probtype):
        num = int(num);
        vehs = int(vehs);
        custs = int(custs);
        speed = int(speed);
        freq = int(freq);
        delay = int(delay);
        max_early = int((vehs+custs)/freq)
        max_delay = delay*60; # delay is in minutes

        if probtype == "SR":
            for i in range(num):
                with open(prefix + '_' + str(i+1) + ".instance", 'w') as fout:
                    fout.write(prefix + '\n')
                    rnet_name = (self.rnet).split('/').pop().split('.rnet')[0]
                    fout.write(rnet_name+'\n')
                    fout.write('VEHICLES ' + str(vehs) + '\n')
                    fout.write('CUSTOMERS ' + str(custs) + '\n')
                    fout.write('\n')
                    fout.write('ID\tORIGIN\tDEST\tQ\tEARLY\tLATE\n')
                    idxs = [i for i in range(vehs + custs)]
                    random.shuffle(idxs)
                    id_count = 1
                    for idx in idxs:
                        sys.stdout.write('{}\{}\r'.format(id_count,(vehs+custs)))
                        sys.stdout.flush()
                        origin = self.random_pick_node()
                        dest = self.random_pick_node()
                        while dest == origin:
                            dest = self.random_pick_node()
                        trip_time = self.shortest_path_time(origin, dest, speed)
                        trip_early = random.randint(0, max_early)
                        trip_late = trip_time + trip_early + random.randint(0, max_delay)
                        cap = 1;
                        if idx < vehs*.1:
                            cap = 7
                        elif idx < vehs*.6:
                            cap = 3
                        elif idx < vehs*.8:
                            cap = 2
                        if idx < vehs:
                            fout.write('\t'.join([str(id_count), str(origin), str(dest), str(-cap), str(trip_early),
                                str(trip_late)]) + '\n')
                        else:
                            fout.write('\t'.join([str(id_count), str(origin), str(dest), str(1), str(trip_early),
                                str(trip_late)]) + '\n')
                        id_count += 1
            print()
            print("Done")
        elif probtype == "SC":
            for k in range(num):
                n = self.graph.number_of_nodes()
                random.seed()
                S = random.randrange(5,10)
                sys.stdout.write('seeds={}\n'.format(S))
                seeds = []
                i = 0
                while i < S:
                    seeds.append(self.random_pick_node())
                    i+=1
                candidates = []
                while len(candidates) <= 2*(vehs + custs):
                    sys.stdout.write('cands={}\{}\r'.format(len(candidates),2*(vehs+custs)))
                    x = self.random_pick_node()
                    p = 0;
                    for s in seeds:
                        p += math.exp(self.haversine(self.nodes[s],self.nodes[x])*(-1)/300)
                    if random.random() < p:
                        candidates.append(x)
                print()
                with open(prefix + '_' + str(k+1) + ".instance", 'w') as fout:
                    fout.write(prefix + '\n')
                    rnet_name = (self.rnet).split('/').pop().split('.rnet')[0]
                    fout.write(rnet_name+'\n')
                    fout.write('VEHICLES ' + str(vehs) + '\n')
                    fout.write('CUSTOMERS ' + str(custs) + '\n')
                    fout.write('\n')
                    fout.write('ID\tORIGIN\tDEST\tQ\tEARLY\tLATE\n')
                    idxs = [i for i in range(vehs + custs)]
                    random.shuffle(idxs)
                    id_count = 1
                    for idx in idxs:
                        sys.stdout.write('{}\{}\r'.format(id_count,(vehs+custs)))
                        sys.stdout.flush()
                        origin = candidates.pop()
                        dest = candidates.pop()
                        trip_time = self.shortest_path_time(origin, dest, speed)
                        trip_early = random.randint(0, max_early)
                        trip_late = trip_time + trip_early + random.randint(0, max_delay)
                        cap = 1;
                        if idx < vehs*.1:
                            cap = 7
                        elif idx < vehs*.6:
                            cap = 3
                        elif idx < vehs*.8:
                            cap = 2
                        if idx < vehs:
                            fout.write('\t'.join([str(id_count), str(origin), str(dest), str(-cap), str(trip_early),
                                str(trip_late)]) + '\n')
                        else:
                            fout.write('\t'.join([str(id_count), str(origin), str(dest), str(1), str(trip_early),
                                str(trip_late)]) + '\n')
                        id_count += 1
            print()
            print("Done")

    def set_min_max(self, node):
        if node.lon < self.min_lon:
            self.min_lon = node.lon
        if node.lon > self.max_lon:
            self.max_lon = node.lon
        if node.lat < self.min_lat:
            self.min_lat = node.lat
        if node.lat > self.max_lat:
            self.max_lat = node.lat

    def get_index(self, node):
        lat_num = int((node.lat - self.min_lat) / self.grid_lat)
        lon_num = int((node.lon - self.min_lon) / self.grid_lon)
        return lat_num * self.grid_size + lon_num

    def random_pick_node(self):
        while True:
            random.seed()
            node_list = self.grid_index[random.randrange(
                self.grid_size * self.grid_size)]
            if len(node_list) is not 0:
                return random.choice(node_list)

    def shortest_path_time(self, origin, dest, speed):
        route_distance = nx.shortest_path_length(
            self.graph, source=origin, target=dest, weight='weight')
        # print(route_distance)
        return round(route_distance / speed)

    def haversine(self, origin, dest):
        lon1 = origin.lon
        lat1 = origin.lat
        lon2 = dest.lon
        lat2 = dest.lat
        radius = 6371000  # meters

        dlat = math.radians(lat2-lat1)
        dlon = math.radians(lon2-lon1)
        a = math.sin(dlat / 2) * math.sin(dlat / 2) + math.cos(math.radians(lat1)) * \
            math.cos(math.radians(lat2)) * \
            math.sin(dlon / 2) * math.sin(dlon / 2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
        return radius * c


def get_parser():
    p = argparse.ArgumentParser(description="Generate RSP instances")
    p.add_argument("rnet_file")
    p.add_argument("num_customers")
    p.add_argument("num_vehicles")
    p.add_argument("type", choices=["SR","SC"])
    p.add_argument("-f", "--freq", metavar="FREQ", type=int, help="stream frequency (default: 5/s)", default=5)
    p.add_argument("-s", "--speed", metavar="SPEED", type=int, help="vehicle speed (default: 10 m/s)", default=10)
    p.add_argument("-d", "--delay", metavar="DELAY", type=int, help="max vehicle delay (default: 10 min)", default=10)
    p.add_argument("-g", "--grid", metavar="GRID", type=int, help="# of grid cells (default: 100)", default=100)
    p.add_argument("-n", "--num", metavar="NUM", type=int, help="# of instances (default: 1)", default=1)
    p.add_argument("-o", "--out", metavar="OUTPUT", help="output dest (default: a.instance)", default="a")
    return p;


def rspgen(args):
    tg = TripGenerator(args["grid"], args["rnet_file"]);
    tg.generate(args["out"], args["num"], args["num_vehicles"], args["num_customers"], args["speed"],
            args["freq"], args["delay"], args["type"]);


if __name__ == "__main__":
    rspgen(vars(get_parser().parse_args()))

